###############################################################################
#                                                                             #
# IAR C/C++ Compiler V8.10.3.10338/W32 for 8051         11/Aug/2015  23:42:32 #
# Copyright 2004-2011 IAR Systems AB.                                         #
#                                                                             #
#    Core               =  plain                                              #
#    Code model         =  banked                                             #
#    Data model         =  large                                              #
#    Calling convention =  xdata reentrant                                    #
#    Constant location  =  data_rom                                           #
#    Dptr setup         =  1,16                                               #
#    Source file        =  C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Comp #
#                          onents\hal\target\CC2530EB\hal_sleep.c             #
#    Command line       =  -f C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\P #
#                          rojects\zstack\Samples\SampleApp\CC2530DB\..\..\.. #
#                          \Tools\CC2530DB\f8wEndev.cfg (-DCPU32MHZ           #
#                          -DROOT=__near_func -DMAC_CFG_TX_DATA_MAX=3         #
#                          -DMAC_CFG_TX_MAX=6 -DMAC_CFG_RX_MAX=3) -f          #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\To #
#                          ols\CC2530DB\f8wConfig.cfg (-DZIGBEEPRO            #
#                          -DSECURE=0 -DZG_SECURE_DYNAMIC=0 -DREFLECTOR       #
#                          -DDEFAULT_CHANLIST=0x00000800                      #
#                          -DZDAPP_CONFIG_PAN_ID=0x0101                       #
#                          -DNWK_START_DELAY=100 -DEXTENDED_JOINING_RANDOM_MA #
#                          SK=0x007F -DBEACON_REQUEST_DELAY=500               #
#                          -DBEACON_REQ_DELAY_MASK=0x00FF                     #
#                          -DLINK_STATUS_JITTER_MASK=0x007F                   #
#                          -DROUTE_EXPIRY_TIME=30 -DAPSC_ACK_WAIT_DURATION_PO #
#                          LLED=3000 -DNWK_INDIRECT_MSG_TIMEOUT=7             #
#                          -DMAX_RREQ_ENTRIES=8 -DAPSC_MAX_FRAME_RETRIES=3    #
#                          -DNWK_MAX_DATA_RETRIES=2                           #
#                          -DMAX_POLL_FAILURE_RETRIES=2 -DMAX_BCAST=9         #
#                          -DAPS_MAX_GROUPS=16 -DMAX_RTG_ENTRIES=40           #
#                          -DNWK_MAX_BINDING_ENTRIES=4                        #
#                          -DMAX_BINDING_CLUSTER_IDS=4 "-DDEFAULT_KEY={0x01,  #
#                          0x03, 0x05, 0x07, 0x09, 0x0B, 0x0D, 0x0F, 0x00,    #
#                          0x02, 0x04, 0x06, 0x08, 0x0A, 0x0C, 0x0D}"         #
#                          -DMAC_MAX_FRAME_SIZE=116                           #
#                          -DZDNWKMGR_MIN_TRANSMISSIONS=20 "-DCONST=const     #
#                          __code" -DGENERIC=__generic                        #
#                          -DRFD_RCVC_ALWAYS_ON=FALSE -DPOLL_RATE=1000        #
#                          -DQUEUED_POLL_RATE=100 -DRESPONSE_POLL_RATE=100)   #
#                          -DREJOIN_POLL_RATE=440 C:\Users\boyangel\Desktop\Õ #
#                          ýÊ½°æ-4.0\EndDvice\Components\hal\target\CC2530EB\ #
#                          hal_sleep.c -D xNWK_AUTO_POLL -D POWER_SAVING -D   #
#                          endA06 -D AUTO_RESET -D xMT_TASK -D xMT_SYS_FUNC   #
#                          -D xMT_ZDO_FUNC -D xLCD_SUPPORTED=DEBUG -lC        #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB #
#                          \List\ -lA C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\En #
#                          dDvice\Projects\zstack\Samples\SampleApp\CC2530DB\ #
#                          EndDeviceEB\List\ --diag_suppress Pe001,Pa010 -o   #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB #
#                          \Obj\ -e --no_code_motion --debug --core=plain     #
#                          --dptr=16,1 --data_model=large                     #
#                          --code_model=banked --calling_convention=xdata_ree #
#                          ntrant --place_constants=data_rom                  #
#                          --nr_virtual_regs 16 -I C:\Users\boyangel\Desktop\ #
#                          ÕýÊ½°æ-4.0\EndDvice\Projects\zstack\Samples\Sample #
#                          App\CC2530DB\ -I C:\Users\boyangel\Desktop\ÕýÊ½°æ- #
#                          4.0\EndDvice\Projects\zstack\Samples\SampleApp\CC2 #
#                          530DB\..\Source\ -I C:\Users\boyangel\Desktop\ÕýÊ½ #
#                          °æ-4.0\EndDvice\Projects\zstack\Samples\SampleApp\ #
#                          CC2530DB\..\..\..\ZMain\TI2530DB\ -I               #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\hal\include\ -I                     #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\hal\target\CC2530EB\ -I             #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\include\ -I                     #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\high_level\ -I                  #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\low_level\srf04\ -I             #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\mac\low_level\srf04\single_chip\    #
#                          -I C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\P #
#                          rojects\zstack\Samples\SampleApp\CC2530DB\..\..\.. #
#                          \..\..\Components\mt\ -I                           #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\osal\include\ -I                    #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\saddr\ -I                  #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\services\sdata\ -I                  #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\af\ -I                        #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\nwk\ -I                       #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sapi\ -I                      #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sec\ -I                       #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\sys\ -I                       #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\stack\zdo\ -I                       #
#                          C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\..\..\..\.. #
#                          \..\Components\zmac\ -I C:\Users\boyangel\Desktop\ #
#                          ÕýÊ½°æ-4.0\EndDvice\Projects\zstack\Samples\Sample #
#                          App\CC2530DB\..\..\..\..\..\Components\zmac\f8w\   #
#                          -Ohz --require_prototypes                          #
#    List file          =  C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB #
#                          \List\hal_sleep.lst                                #
#    Object file        =  C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Proj #
#                          ects\zstack\Samples\SampleApp\CC2530DB\EndDeviceEB #
#                          \Obj\hal_sleep.r51                                 #
#                                                                             #
#                                                                             #
###############################################################################

C:\Users\boyangel\Desktop\ÕýÊ½°æ-4.0\EndDvice\Components\hal\target\CC2530EB\hal_sleep.c
      1          /**************************************************************************************************
      2            Filename:       hal_sleep.c
      3            Revised:        $Date: 2012-03-07 11:55:12 -0800 (Wed, 07 Mar 2012) $
      4            Revision:       $Revision: 29664 $
      5          
      6            Description:    This module contains the HAL power management procedures for the CC2530.
      7          
      8          
      9            Copyright 2006-2012 Texas Instruments Incorporated. All rights reserved.
     10          
     11            IMPORTANT: Your use of this Software is limited to those specific rights
     12            granted under the terms of a software license agreement between the user
     13            who downloaded the software, his/her employer (which must be your employer)
     14            and Texas Instruments Incorporated (the "License").  You may not use this
     15            Software unless you agree to abide by the terms of the License. The License
     16            limits your use, and you acknowledge, that the Software may not be modified,
     17            copied or distributed unless embedded on a Texas Instruments microcontroller
     18            or used solely and exclusively in conjunction with a Texas Instruments radio
     19            frequency transceiver, which is integrated into your product.  Other than for
     20            the foregoing purpose, you may not use, reproduce, copy, prepare derivative
     21            works of, modify, distribute, perform, display or sell this Software and/or
     22            its documentation for any purpose.
     23          
     24            YOU FURTHER ACKNOWLEDGE AND AGREE THAT THE SOFTWARE AND DOCUMENTATION ARE
     25            PROVIDED AS IS?WITHOUT WARRANTY OF ANY KIND, EITHER EXPRESS OR IMPLIED,
     26            INCLUDING WITHOUT LIMITATION, ANY WARRANTY OF MERCHANTABILITY, TITLE,
     27            NON-INFRINGEMENT AND FITNESS FOR A PARTICULAR PURPOSE. IN NO EVENT SHALL
     28            TEXAS INSTRUMENTS OR ITS LICENSORS BE LIABLE OR OBLIGATED UNDER CONTRACT,
     29            NEGLIGENCE, STRICT LIABILITY, CONTRIBUTION, BREACH OF WARRANTY, OR OTHER
     30            LEGAL EQUITABLE THEORY ANY DIRECT OR INDIRECT DAMAGES OR EXPENSES
     31            INCLUDING BUT NOT LIMITED TO ANY INCIDENTAL, SPECIAL, INDIRECT, PUNITIVE
     32            OR CONSEQUENTIAL DAMAGES, LOST PROFITS OR LOST DATA, COST OF PROCUREMENT
     33            OF SUBSTITUTE GOODS, TECHNOLOGY, SERVICES, OR ANY CLAIMS BY THIRD PARTIES
     34            (INCLUDING BUT NOT LIMITED TO ANY DEFENSE THEREOF), OR OTHER SIMILAR COSTS.
     35          
     36            Should you have any questions regarding your right to use this Software,
     37            contact Texas Instruments Incorporated at www.TI.com.
     38          **************************************************************************************************/
     39          
     40          /* ------------------------------------------------------------------------------------------------
     41           *                                          Includes
     42           * ------------------------------------------------------------------------------------------------
     43           */
     44          #include "hal_types.h"
     45          #include "hal_mcu.h"

   \                                 In  segment SFR_AN, at 0x87
   \   unsigned char volatile __sfr PCON
   \                     PCON:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x95
   \   unsigned char volatile __sfr ST0
   \                     ST0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x96
   \   unsigned char volatile __sfr ST1
   \                     ST1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x97
   \   unsigned char volatile __sfr ST2
   \                     ST2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0x9a
   \   unsigned char volatile __sfr IEN2
   \                     IEN2:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xa8
   \   union <unnamed> volatile __sfr _A_IEN0
   \                     _A_IEN0:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xad
   \   unsigned char volatile __sfr STLOAD
   \                     STLOAD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xb8
   \   union <unnamed> volatile __sfr _A_IEN1
   \                     _A_IEN1:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xbe
   \   unsigned char volatile __sfr SLEEPCMD
   \                     SLEEPCMD:
   \   000000                DS 1

   \                                 In  segment SFR_AN, at 0xc0
   \   union <unnamed> volatile __sfr _A_IRCON
   \                     _A_IRCON:
   \   000000                DS 1
     46          #include "hal_board.h"
     47          #include "hal_sleep.h"
     48          #include "hal_led.h"
     49          #include "hal_key.h"
     50          #include "mac_api.h"
     51          #include "OSAL.h"
     52          #include "OSAL_Timers.h"
     53          #include "OSAL_Clock.h"
     54          #include "OSAL_Tasks.h"
     55          #include "OSAL_PwrMgr.h"
     56          #include "OnBoard.h"
     57          #include "hal_drivers.h"
     58          #include "hal_assert.h"
     59          #include "mac_mcu.h"
     60          #include "SampleApp.h"
     61          #include "ZDApp.h"
     62          #include "ZDObject.h"
     63          #ifndef ZG_BUILD_ENDDEVICE_TYPE
     64          # define ZG_BUILD_ENDDEVICE_TYPE FALSE
     65          #endif
     66          
     67          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
     68          #include "nwk_globals.h"
     69          #include "ZGlobals.h"
     70          #endif
     71          
     72          #define MaxSleepTime 64000            //Ã¿´ÎË¯ÃßµÄ×î´óÊ±¼ä

   \                                 In  segment XDATA_I, align 1, keep-with-next
     73          uint32 Time_Interval=3600000;         //Êý¾Ý²É¼¯¼ä¸ô
   \                     Time_Interval:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for Time_Interval>`
   \   000004                REQUIRE __INIT_XDATA_I
     74          /* ------------------------------------------------------------------------------------------------
     75           *                                           Macros
     76           * ------------------------------------------------------------------------------------------------
     77           */
     78          
     79          /* POWER CONSERVATION DEFINITIONS
     80           * Sleep mode H/W definitions (enabled with POWER_SAVING compile option)
     81           */
     82          #define CC2530_PM0            0  /* PM0, Clock oscillators on, voltage regulator on */
     83          #define CC2530_PM1            1  /* PM1, 32.768 kHz oscillators on, voltage regulator on */
     84          #define CC2530_PM2            2  /* PM2, 32.768 kHz oscillators on, voltage regulator off */
     85          #define CC2530_PM3            3  /* PM3, All clock oscillators off, voltage regulator off */
     86          
     87          /* HAL power management mode is set according to the power management state. The default
     88           * setting is HAL_SLEEP_OFF. The actual value is tailored to different HW platform. Both
     89           * HAL_SLEEP_TIMER and HAL_SLEEP_DEEP selections will:
     90           *   1. turn off the system clock, and
     91           *   2. halt the MCU.
     92           * HAL_SLEEP_TIMER can be woken up by sleep timer interrupt, I/O interrupt and reset.
     93           * HAL_SLEEP_DEEP can be woken up by I/O interrupt and reset.
     94           */
     95          #define HAL_SLEEP_OFF         CC2530_PM0
     96          #define HAL_SLEEP_TIMER       CC2530_PM2
     97          #define HAL_SLEEP_DEEP        CC2530_PM3
     98          
     99          /* MAX_SLEEP_TIME calculation:
    100           *   Sleep timer maximum duration = 0xFFFF7F / 32768 Hz = 511.996 seconds
    101           *   Round it to 510 seconds or 510000 ms
    102           */
    103          #define MAX_SLEEP_TIME                   510000             /* maximum time to sleep allowed by ST */
    104          #define TICKS_SUBTRACTED                 2
    105          
    106          /* minimum time to sleep, this macro is to:
    107           * 1. avoid thrashing in-and-out of sleep with short OSAL timer (~2ms)
    108           * 2. define minimum safe sleep period
    109           */
    110          #if !defined (PM_MIN_SLEEP_TIME)
    111          #define PM_MIN_SLEEP_TIME                14                 /* default to minimum safe sleep time minimum CAP */
    112          #endif
    113          
    114          /* The PCON instruction must be 4-byte aligned. The following code may cause excessive power
    115           * consumption if not aligned. See linker file ".xcl" for actual placement.
    116           */
    117          #pragma location = "SLEEP_CODE"
    118          void halSetSleepMode(void);
    119          
    120          /* This value is used to adjust the sleep timer compare value such that the sleep timer
    121           * compare takes into account the amount of processing time spent in function halSleep().
    122           * The first value is determined by measuring the number of sleep timer ticks it from
    123           * the beginning of the function to entering sleep mode or more precisely, when
    124           * MAC_PwrNextTimeout() is called.  The second value is determined by measuring the number
    125           * of sleep timer ticks from exit of sleep mode to the call to MAC_PwrOnReq() where the
    126           * MAC timer is restarted.
    127           */
    128          #define HAL_SLEEP_ADJ_TICKS   (11 + 12)
    129          
    130          #ifndef HAL_SLEEP_DEBUG_POWER_MODE
    131          /* set CC2530 power mode; always use PM2 */
    132          #define HAL_SLEEP_PREP_POWER_MODE(mode)     st( SLEEPCMD &= ~PMODE; /* clear mode bits */    \
    133                                                          SLEEPCMD |= mode;   /* set mode bits   */    \
    134                                                          while (!(STLOAD & LDRDY));                   \
    135                                                          halSleepPconValue = PCON_IDLE;               \
    136                                                        )
    137          #define HAL_SLEEP_SET_POWER_MODE()          halSetSleepMode()
    138          #else
    139          /* Debug: don't set power mode, just block until sleep timer interrupt */
    140          #define HAL_SLEEP_PREP_POWER_MODE(mode)     /* nothing */
    141          #define HAL_SLEEP_SET_POWER_MODE()          st( while(halSleepInt == FALSE); \
    142                                                          halSleepInt = FALSE;         \
    143                                                          HAL_DISABLE_INTERRUPTS();    \
    144                                                        )
    145          #endif
    146          
    147          /* sleep and external interrupt port masks */
    148          #define STIE_BV                             BV(5)
    149          #define P0IE_BV                             BV(5)
    150          #define P1IE_BV                             BV(4)
    151          #define P2IE_BV                             BV(1)
    152          
    153          /* sleep timer interrupt control */
    154          #define HAL_SLEEP_TIMER_ENABLE_INT()        st(IEN0 |= STIE_BV;)     /* enable sleep timer interrupt */
    155          #define HAL_SLEEP_TIMER_DISABLE_INT()       st(IEN0 &= ~STIE_BV;)    /* disable sleep timer interrupt */
    156          #define HAL_SLEEP_TIMER_CLEAR_INT()         st(STIF = 0;)            /* clear sleep interrupt flag */
    157          
    158          /* backup interrupt enable registers before sleep */
    159          #define HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2) st(ien0  = IEN0;    /* backup IEN0 register */ \
    160                                                                       ien1  = IEN1;    /* backup IEN1 register */ \
    161                                                                       ien2  = IEN2;    /* backup IEN2 register */ \
    162                                                                       IEN0 &= STIE_BV; /* disable IEN0 except STIE */ \
    163                                                                       IEN1 &= P0IE_BV; /* disable IEN1 except P0IE */ \
    164                                                                       IEN2 &= (P1IE_BV|P2IE_BV);) /* disable IEN2 except P1IE, P2IE */
    165          
    166          /* restore interrupt enable registers before sleep */
    167          #define HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2) st(IEN0 = ien0;   /* restore IEN0 register */ \
    168                                                            IEN1 = ien1;   /* restore IEN1 register */ \
    169                                                            IEN2 = ien2;)  /* restore IEN2 register */
    170          
    171          /* convert msec to 320 usec units with round */
    172          #define HAL_SLEEP_MS_TO_320US(ms)           (((((uint32) (ms)) * 100) + 31) / 32)
    173          
    174          /* for optimized indexing of uint32's */
    175          #if HAL_MCU_LITTLE_ENDIAN()
    176          #define UINT32_NDX0   0
    177          #define UINT32_NDX1   1
    178          #define UINT32_NDX2   2
    179          #define UINT32_NDX3   3
    180          #else
    181          #define UINT32_NDX0   3
    182          #define UINT32_NDX1   2
    183          #define UINT32_NDX2   1
    184          #define UINT32_NDX3   0
    185          #endif
    186          

   \                                 In  segment XDATA_I, align 1, keep-with-next
    187          static uint32 maxSleepLoopTime =  HAL_SLEEP_MS_TO_320US(MAX_SLEEP_TIME);
   \                     maxSleepLoopTime:
   \   000000                DS 4
   \   000004                REQUIRE `?<Initializer for maxSleepLoopTime>`
   \   000004                REQUIRE __INIT_XDATA_I
    188          
    189          /* ------------------------------------------------------------------------------------------------
    190           *                                        Global Variables
    191           * ------------------------------------------------------------------------------------------------
    192           */
    193          /* PCON register value to program when setting power mode */

   \                                 In  segment DATA_I, align 1, keep-with-next
    194          volatile __data uint8 halSleepPconValue = PCON_IDLE;
   \                     halSleepPconValue:
   \   000000                DS 1
   \   000001                REQUIRE `?<Initializer for halSleepPconValue>`
   \   000001                REQUIRE __INIT_DATA_I
    195          
    196          /* ------------------------------------------------------------------------------------------------
    197           *                                        Local Variables
    198           * ------------------------------------------------------------------------------------------------
    199           */
    200          
    201          /* HAL power management mode is set according to the power management state.
    202           */

   \                                 In  segment XDATA_Z, align 1, keep-with-next
    203          static uint8 halPwrMgtMode = HAL_SLEEP_OFF;
   \                     halPwrMgtMode:
   \   000000                DS 1
   \   000001                REQUIRE __INIT_XDATA_Z
    204          
    205          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    206          static bool halSleepInt = FALSE;
    207          #endif
    208          
    209          /* ------------------------------------------------------------------------------------------------
    210           *                                      Function Prototypes
    211           * ------------------------------------------------------------------------------------------------
    212           */
    213          
    214          void halSleepSetTimer(uint32 timeout);
    215          
    216          /**************************************************************************************************
    217           * @fn          halSleep
    218           *
    219           * @brief       This function put the CC2530 to sleep. The PCON instruction must be 4-byte aligned.
    220           *              The following code may cause excessive power consumption if not aligned. See linker
    221           *              file ".xcl" for actual placement.
    222           *
    223           * input parameters
    224           *
    225           * @param       None.
    226           *
    227           * output parameters
    228           *
    229           * None.
    230           *
    231           * @return      None.
    232           **************************************************************************************************
    233           */

   \                                 In  segment SLEEP_CODE, align 1, keep-with-next
    234          void halSetSleepMode(void)
   \                     halSetSleepMode:
    235          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    236            PCON = halSleepPconValue;
   \   000000   85..87       MOV     0x87,halSleepPconValue
    237            HAL_DISABLE_INTERRUPTS();
   \   000003   C2AF         CLR     0xa8.7
    238          }
   \   000005   02....       LJMP    ?BRET
   \   000008                REQUIRE PCON
   \   000008                REQUIRE _A_IEN0
    239          
    240          /**************************************************************************************************
    241           * @fn          halSetMaxSleepLoopTime
    242           *
    243           * @brief       This function is to used to setup the maximum sleep loop time. This sleep loop time 
    244           *              should be lesser than T2 rollover so that a maximum of only one rollover occurs 
    245           *              when cc2530 is in sleep. This function should be called whenever rolloverTime is 
    246           *              changed using the function macBackoffTimerSetRollover(macTimerRollover);
    247           *
    248           * input parameters
    249           *
    250           * @param       rolloverTime.
    251           *
    252           * output parameters
    253           *
    254           * None.
    255           *
    256           * @return      None.
    257           **************************************************************************************************
    258           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    259          void halSetMaxSleepLoopTime(uint32 rolloverTime)
   \                     halSetMaxSleepLoopTime:
    260          {
   \   000000   74F4         MOV     A,#-0xc
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 12
   \   000005                ; Auto size: 0
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   8C..         MOV     ?V0 + 2,R4
   \   00000B   8D..         MOV     ?V0 + 3,R5
    261            if( rolloverTime > HAL_SLEEP_MS_TO_320US(MAX_SLEEP_TIME) )
    262            {
    263              maxSleepLoopTime = HAL_SLEEP_MS_TO_320US(MAX_SLEEP_TIME);
    264            }
    265            maxSleepLoopTime = (rolloverTime - TICKS_SUBTRACTED);
   \   00000D   90....       MOV     DPTR,#__Constant_fffffffe
   \   000010   78..         MOV     R0,#?V0 + 0
   \   000012   12....       LCALL   ?L_ADD_X
   \   000015   90....       MOV     DPTR,#maxSleepLoopTime
   \   000018   78..         MOV     R0,#?V0 + 0
   \   00001A   12....       LCALL   ?L_MOV_TO_X
    266          }
   \   00001D   7F04         MOV     R7,#0x4
   \   00001F   02....       LJMP    ?BANKED_LEAVE_XDATA
    267          
    268          /**************************************************************************************************
    269           * @fn          halSleep
    270           *
    271           * @brief       This function is called from the OSAL task loop using and existing OSAL
    272           *              interface.  It sets the low power mode of the MAC and the CC2530.
    273           *
    274           * input parameters
    275           *
    276           * @param       osal_timeout - Next OSAL timer timeout.
    277           *
    278           * output parameters
    279           *
    280           * None.
    281           *
    282           * @return      None.
    283           **************************************************************************************************
    284           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    285          void halSleep( uint16 osal_timeout )
   \                     halSleep:
    286          {
   \   000000   74EC         MOV     A,#-0x14
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 20
   \   000005                ; Auto size: 0
    287            uint32        timeout;
    288            uint32        macTimeout = 0;
    289          
    290            /* get next OSAL timer expiration converted to 320 usec units */
    291            timeout = HAL_SLEEP_MS_TO_320US(osal_timeout);
   \   000005   8A..         MOV     ?V0 + 0,R2
   \   000007   8B..         MOV     ?V0 + 1,R3
   \   000009   E4           CLR     A
   \   00000A   F5..         MOV     ?V0 + 2,A
   \   00000C   F5..         MOV     ?V0 + 3,A
   \   00000E   90....       MOV     DPTR,#__Constant_64
   \   000011   78..         MOV     R0,#?V0 + 4
   \   000013   12....       LCALL   ?L_MOV_X
   \   000016   78..         MOV     R0,#?V0 + 0
   \   000018   79..         MOV     R1,#?V0 + 4
   \   00001A   12....       LCALL   ?L_MUL
   \   00001D   90....       MOV     DPTR,#__Constant_1f
   \   000020   78..         MOV     R0,#?V0 + 0
   \   000022   12....       LCALL   ?L_ADD_X
   \   000025   7405         MOV     A,#0x5
   \   000027   78..         MOV     R0,#?V0 + 0
   \   000029   12....       LCALL   ?UL_SHR
    292            if (timeout == 0)
   \   00002C   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_1:
   \   00002F   7019         JNZ     ??halSleep_0
    293            {
    294              timeout = MAC_PwrNextTimeout();
   \   000031                ; Setup parameters for call to function MAC_PwrNextTimeout
   \   000031   12....       LCALL   ??MAC_PwrNextTimeout?relay
   \   000034   8A..         MOV     ?V0 + 0,R2
   \   000036   8B..         MOV     ?V0 + 1,R3
   \   000038   8C..         MOV     ?V0 + 2,R4
   \   00003A   8D..         MOV     ?V0 + 3,R5
    295            }
    296            else
    297            {
    298              /* get next MAC timer expiration */
    299              macTimeout = MAC_PwrNextTimeout();
    300          
    301              /* get lesser of two timeouts */
    302              if ((macTimeout != 0) && (macTimeout < timeout))
    303              {
    304                timeout = macTimeout;
    305              }
    306            }
    307          
    308            /* HAL_SLEEP_PM2 is entered only if the timeout is zero and
    309             * the device is a stimulated device.
    310             */
    311            halPwrMgtMode = (timeout == 0) ? HAL_SLEEP_DEEP : HAL_SLEEP_TIMER;
   \   00003C   EA           MOV     A,R2
   \   00003D   12....       LCALL   ??Subroutine1_0 & 0xFFFF
   \                     ??CrossCallReturnLabel_0:
   \   000040   702D         JNZ     ??halSleep_1
   \   000042   90....       MOV     DPTR,#halPwrMgtMode
   \   000045   7403         MOV     A,#0x3
   \   000047   F0           MOVX    @DPTR,A
   \   000048   803D         SJMP    ??halSleep_2
   \                     ??halSleep_0:
   \   00004A                ; Setup parameters for call to function MAC_PwrNextTimeout
   \   00004A   12....       LCALL   ??MAC_PwrNextTimeout?relay
   \   00004D   8A..         MOV     ?V0 + 4,R2
   \   00004F   8B..         MOV     ?V0 + 5,R3
   \   000051   8C..         MOV     ?V0 + 6,R4
   \   000053   8D..         MOV     ?V0 + 7,R5
   \   000055   EA           MOV     A,R2
   \   000056   45..         ORL     A,?V0 + 5
   \   000058   45..         ORL     A,?V0 + 6
   \   00005A   45..         ORL     A,?V0 + 7
   \   00005C   6011         JZ      ??halSleep_1
   \   00005E   78..         MOV     R0,#?V0 + 0
   \   000060   79..         MOV     R1,#?V0 + 4
   \   000062   12....       LCALL   ?UL_GT
   \   000065   5008         JNC     ??halSleep_1
   \   000067   8A..         MOV     ?V0 + 0,R2
   \   000069   8B..         MOV     ?V0 + 1,R3
   \   00006B   8C..         MOV     ?V0 + 2,R4
   \   00006D   8D..         MOV     ?V0 + 3,R5
   \                     ??halSleep_1:
   \   00006F   90....       MOV     DPTR,#halPwrMgtMode
   \   000072   7402         MOV     A,#0x2
   \   000074   F0           MOVX    @DPTR,A
    312          
    313            /* DEEP sleep can only be entered when zgPollRate == 0.
    314             * This is to eliminate any possibility of entering PM3 between
    315             * two network timers.
    316             */
    317          #if ZG_BUILD_ENDDEVICE_TYPE && defined (NWK_AUTO_POLL)
    318            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    319                (timeout == 0 && zgPollRate == 0))
    320          #else
    321            if ((timeout > HAL_SLEEP_MS_TO_320US(PM_MIN_SLEEP_TIME)) ||
    322                (timeout == 0))
   \   000075   90....       MOV     DPTR,#__Constant_2d
   \   000078   78..         MOV     R0,#?V0 + 0
   \   00007A   12....       LCALL   ?UL_GE_X
   \   00007D   4008         JC      ??halSleep_2
   \   00007F   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_2:
   \   000082   6003         JZ      $+5
   \   000084   02....       LJMP    ??halSleep_3 & 0xFFFF
    323          #endif
    324            {
    325              halIntState_t ien0, ien1, ien2;
    326          
    327              HAL_ASSERT(HAL_INTERRUPTS_ARE_ENABLED());
   \                     ??halSleep_2:
   \   000087   A2AF         MOV     C,0xa8.7
   \   000089   4003         JC      ??halSleep_4
   \   00008B                ; Setup parameters for call to function halAssertHandler
   \   00008B   12....       LCALL   ??halAssertHandler?relay
    328              HAL_DISABLE_INTERRUPTS();
   \                     ??halSleep_4:
   \   00008E   C2AF         CLR     0xa8.7
    329          
    330              /* always use "deep sleep" to turn off radio VREG on CC2530 */
    331              if (halSleepPconValue != 0 && MAC_PwrOffReq(MAC_PWR_SLEEP_DEEP) == MAC_SUCCESS)
   \   000090   E5..         MOV     A,halSleepPconValue
   \   000092   7003         JNZ     $+5
   \   000094   02....       LJMP    ??halSleep_5 & 0xFFFF
   \   000097                ; Setup parameters for call to function MAC_PwrOffReq
   \   000097   7902         MOV     R1,#0x2
   \   000099   12....       LCALL   ??MAC_PwrOffReq?relay
   \   00009C   E9           MOV     A,R1
   \   00009D   6003         JZ      $+5
   \   00009F   02....       LJMP    ??halSleep_5 & 0xFFFF
    332              {
    333                /* The PCON value is not zero. There is no interrupt overriding the 
    334                 * sleep decision. Also, the radio granted the sleep request.
    335                 */
    336          
    337          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    338                /* get peripherals ready for sleep */
    339                HalKeyEnterSleep();
   \   0000A2                ; Setup parameters for call to function HalKeyEnterSleep
   \   0000A2   12....       LCALL   ??HalKeyEnterSleep?relay
    340          #endif
    341          
    342          #ifdef HAL_SLEEP_DEBUG_LED
    343                HAL_TURN_OFF_LED3();
    344          #else
    345                /* use this to turn LEDs off during sleep */
    346                HalLedEnterSleep();
   \   0000A5                ; Setup parameters for call to function HalLedEnterSleep
   \   0000A5   12....       LCALL   ??HalLedEnterSleep?relay
    347          #endif
    348          
    349                if(timeout > maxSleepLoopTime)
   \   0000A8   90....       MOV     DPTR,#maxSleepLoopTime
   \   0000AB   78..         MOV     R0,#?V0 + 0
   \   0000AD   12....       LCALL   ?UL_GT_X
   \   0000B0   5008         JNC     ??halSleep_6
    350                {
    351                  timeout = maxSleepLoopTime;
   \   0000B2   90....       MOV     DPTR,#maxSleepLoopTime
   \   0000B5   78..         MOV     R0,#?V0 + 0
   \   0000B7   12....       LCALL   ?L_MOV_X
    352                }  
    353          
    354                /* enable sleep timer interrupt */
    355          //***********************ÉèÖÃË¯ÃßÊ±¼ä*****************************************//
    356                if (timeout != 0)
   \                     ??halSleep_6:
   \   0000BA   12....       LCALL   ?Subroutine0 & 0xFFFF
   \                     ??CrossCallReturnLabel_3:
   \   0000BD   7003         JNZ     $+5
   \   0000BF   02....       LJMP    ??halSleep_7 & 0xFFFF
    357                {
    358                    if(CountF==1)                                //Èç¹û¼ÆËãË¯ÃßÊ±¼ä±êÖ¾Î»Îª1 ¼ÆËãË¯ÃßÊ±¼ä
   \   0000C2   90....       MOV     DPTR,#CountF
   \   0000C5   E0           MOVX    A,@DPTR
   \   0000C6   6401         XRL     A,#0x1
   \   0000C8   6003         JZ      $+5
   \   0000CA   02....       LJMP    ??halSleep_8 & 0xFFFF
    359                    {
    360                      CountF=0;                                  //Ïû³ý±êÖ¾Î»
   \   0000CD   E4           CLR     A
   \   0000CE   F0           MOVX    @DPTR,A
    361                      if(Mode=='M')                              //µ÷ÊÔÄ£Ê½²É¼¯¼ä¸ôÎª2min
   \   0000CF   90....       MOV     DPTR,#Mode
   \   0000D2   E0           MOVX    A,@DPTR
   \   0000D3   644D         XRL     A,#0x4d
   \   0000D5   7005         JNZ     ??halSleep_9
    362                        Time_Interval=120000;
   \   0000D7   90....       MOV     DPTR,#__Constant_1d4c0
   \   0000DA   8008         SJMP    ??halSleep_10
    363                      else if(Mode=='C')                         //Õý³£Ä£Ê½²É¼¯¼ä¸ôÎª1h
   \                     ??halSleep_9:
   \   0000DC   E0           MOVX    A,@DPTR
   \   0000DD   6443         XRL     A,#0x43
   \   0000DF   700C         JNZ     ??halSleep_11
    364                        Time_Interval=3600000;  
   \   0000E1   90....       MOV     DPTR,#__Constant_36ee80
   \                     ??halSleep_10:
   \   0000E4   12....       LCALL   ?XLOAD_R2345
   \   0000E7   90....       MOV     DPTR,#Time_Interval
   \   0000EA   12....       LCALL   ?XSTORE_R2345
    365                      
    366                      SleepTime=Time_Interval-(osal_systemClock%Time_Interval)+(uint32)delayt;
   \                     ??halSleep_11:
   \   0000ED   90....       MOV     DPTR,#Time_Interval
   \   0000F0   78..         MOV     R0,#?V0 + 0
   \   0000F2   12....       LCALL   ?L_MOV_X
   \   0000F5   90....       MOV     DPTR,#osal_systemClock
   \   0000F8   78..         MOV     R0,#?V0 + 4
   \   0000FA   12....       LCALL   ?L_MOV_X
   \   0000FD   90....       MOV     DPTR,#Time_Interval
   \   000100   78..         MOV     R0,#?V0 + 8
   \   000102   12....       LCALL   ?L_MOV_X
   \   000105   78..         MOV     R0,#?V0 + 4
   \   000107   79..         MOV     R1,#?V0 + 8
   \   000109   12....       LCALL   ?UL_DIV_MOD
   \   00010C   78..         MOV     R0,#?V0 + 0
   \   00010E   79..         MOV     R1,#?V0 + 8
   \   000110   12....       LCALL   ?L_SUB
   \   000113   90....       MOV     DPTR,#__Constant_4d58
   \   000116   78..         MOV     R0,#?V0 + 0
   \   000118   12....       LCALL   ?L_ADD_X
   \   00011B   90....       MOV     DPTR,#SleepTime
   \   00011E   78..         MOV     R0,#?V0 + 0
   \   000120   12....       LCALL   ?L_MOV_TO_X
    367                      
    368                      TCount=(uint8)(SleepTime/MaxSleepTime);    //×î´óË¯ÃßÊ±¼äµÄ¸öÊý
   \   000123   90....       MOV     DPTR,#SleepTime
   \   000126   78..         MOV     R0,#?V0 + 0
   \   000128   12....       LCALL   ?L_MOV_X
   \   00012B   90....       MOV     DPTR,#__Constant_fa00
   \   00012E   78..         MOV     R0,#?V0 + 4
   \   000130   12....       LCALL   ?L_MOV_X
   \   000133   78..         MOV     R0,#?V0 + 0
   \   000135   79..         MOV     R1,#?V0 + 4
   \   000137   12....       LCALL   ?UL_DIV_MOD
   \   00013A   E5..         MOV     A,?V0 + 0
   \   00013C   90....       MOV     DPTR,#TCount
   \   00013F   F0           MOVX    @DPTR,A
    369                      SleepTime=(uint32)(SleepTime%MaxSleepTime);//Ê£ÓàµÄË¯ÃßÊ±¼ä
   \   000140   90....       MOV     DPTR,#SleepTime
   \   000143   78..         MOV     R0,#?V0 + 0
   \   000145   12....       LCALL   ?L_MOV_X
   \   000148   90....       MOV     DPTR,#__Constant_fa00
   \   00014B   78..         MOV     R0,#?V0 + 4
   \   00014D   12....       LCALL   ?L_MOV_X
   \   000150   78..         MOV     R0,#?V0 + 0
   \   000152   79..         MOV     R1,#?V0 + 4
   \   000154   12....       LCALL   ?UL_DIV_MOD
   \   000157   90....       MOV     DPTR,#SleepTime
   \   00015A   78..         MOV     R0,#?V0 + 4
   \   00015C   12....       LCALL   ?L_MOV_TO_X
    370                    }
    371                    if(Requestflag==1)                           //ÍøÂçÖØÁ¬Ë¯Ãß
   \                     ??halSleep_8:
   \   00015F   90....       MOV     DPTR,#Requestflag
   \   000162   E0           MOVX    A,@DPTR
   \   000163   6401         XRL     A,#0x1
   \   000165   7020         JNZ     ??halSleep_12
    372                   {
    373                     if(Mode=='M')                               //µ÷ÊÔÄ£Ê½Ë¯Ãß5S
   \   000167   90....       MOV     DPTR,#Mode
   \   00016A   E0           MOVX    A,@DPTR
   \   00016B   644D         XRL     A,#0x4d
   \   00016D   700E         JNZ     ??halSleep_13
    374                       SleepTime_MS=5000;     
   \   00016F   90....       MOV     DPTR,#__Constant_1388
   \                     ??halSleep_14:
   \   000172   12....       LCALL   ?XLOAD_R2345
   \   000175   90....       MOV     DPTR,#SleepTime_MS
   \   000178   12....       LCALL   ?XSTORE_R2345
   \   00017B   802D         SJMP    ??halSleep_15
    375                     else if(Mode=='C')                          //Õý³£Ä£Ê½Ë¯Ãß1h
   \                     ??halSleep_13:
   \   00017D   E0           MOVX    A,@DPTR
   \   00017E   6443         XRL     A,#0x43
   \   000180   7028         JNZ     ??halSleep_15
    376                      SleepTime_MS=360000;
   \   000182   90....       MOV     DPTR,#__Constant_57e40
   \   000185   80EB         SJMP    ??halSleep_14
    377                   }
    378                   else
    379                   {
    380                       if(TCount>0)
   \                     ??halSleep_12:
   \   000187   90....       MOV     DPTR,#TCount
   \   00018A   E0           MOVX    A,@DPTR
   \   00018B   6007         JZ      ??halSleep_16
    381                       {
    382                         TCount--;
   \   00018D   14           DEC     A
   \   00018E   F0           MOVX    @DPTR,A
    383                         SleepTime_MS=MaxSleepTime;
   \   00018F   90....       MOV     DPTR,#__Constant_fa00
   \   000192   80DE         SJMP    ??halSleep_14
    384                       }
    385                       else
    386                       {
    387                         SleepTime_MS=SleepTime;
   \                     ??halSleep_16:
   \   000194   90....       MOV     DPTR,#SleepTime
   \   000197   12....       LCALL   ?XLOAD_R2345
   \   00019A   90....       MOV     DPTR,#SleepTime_MS
   \   00019D   12....       LCALL   ?XSTORE_R2345
    388                         TX_Flag=1;
   \   0001A0   90....       MOV     DPTR,#TX_Flag
   \   0001A3   7401         MOV     A,#0x1
   \   0001A5   F0           MOVX    @DPTR,A
    389                         CountF=1;
   \   0001A6   90....       MOV     DPTR,#CountF
   \   0001A9   F0           MOVX    @DPTR,A
    390                       }
    391                   }
    392          //****************ÉèÖÃË¯Ãß¶¨Ê±Æ÷ µ¥Î»ÎªMS*************************************//
    393                   halSleepSetTimer(HAL_SLEEP_MS_TO_320US(SleepTime_MS));
   \                     ??halSleep_15:
   \   0001AA                ; Setup parameters for call to function halSleepSetTimer
   \   0001AA   90....       MOV     DPTR,#SleepTime_MS
   \   0001AD   78..         MOV     R0,#?V0 + 0
   \   0001AF   12....       LCALL   ?L_MOV_X
   \   0001B2   90....       MOV     DPTR,#__Constant_64
   \   0001B5   78..         MOV     R0,#?V0 + 4
   \   0001B7   12....       LCALL   ?L_MOV_X
   \   0001BA   78..         MOV     R0,#?V0 + 0
   \   0001BC   79..         MOV     R1,#?V0 + 4
   \   0001BE   12....       LCALL   ?L_MUL
   \   0001C1   90....       MOV     DPTR,#__Constant_1f
   \   0001C4   78..         MOV     R0,#?V0 + 0
   \   0001C6   12....       LCALL   ?L_ADD_X
   \   0001C9   7405         MOV     A,#0x5
   \   0001CB   78..         MOV     R0,#?V0 + 0
   \   0001CD   12....       LCALL   ?UL_SHR
   \   0001D0   AA..         MOV     R2,?V0 + 0
   \   0001D2   AB..         MOV     R3,?V0 + 1
   \   0001D4   AC..         MOV     R4,?V0 + 2
   \   0001D6   AD..         MOV     R5,?V0 + 3
   \   0001D8   12....       LCALL   ??halSleepSetTimer?relay
    394                  
    395                   /* set up sleep timer interrupt */
    396                  HAL_SLEEP_TIMER_CLEAR_INT();
   \   0001DB   C2C7         CLR     0xc0.7
    397                  HAL_SLEEP_TIMER_ENABLE_INT();
   \   0001DD   D2AD         SETB    0xa8.5
    398                }
    399          
    400          #ifdef HAL_SLEEP_DEBUG_LED
    401                if (halPwrMgtMode == CC2530_PM1)
    402                {
    403                  HAL_TURN_ON_LED1();
    404                }
    405                else
    406                {
    407                  HAL_TURN_OFF_LED1();
    408                }
    409          #endif
    410          
    411                /* Prep CC2530 power mode */
    412                HAL_SLEEP_PREP_POWER_MODE(halPwrMgtMode);
   \                     ??halSleep_7:
   \   0001DF   53BEFC       ANL     0xbe,#0xfc
   \   0001E2   90....       MOV     DPTR,#halPwrMgtMode
   \   0001E5   E0           MOVX    A,@DPTR
   \   0001E6   42BE         ORL     0xbe,A
   \                     ??halSleep_17:
   \   0001E8   E5AD         MOV     A,0xad
   \   0001EA   A2E0         MOV     C,0xE0 /* A   */.0
   \   0001EC   50FA         JNC     ??halSleep_17
   \   0001EE   75..01       MOV     halSleepPconValue,#0x1
    413          
    414                /* save interrupt enable registers and disable all interrupts */
    415                HAL_SLEEP_IE_BACKUP_AND_DISABLE(ien0, ien1, ien2);
   \   0001F1   E5A8         MOV     A,0xa8
   \   0001F3   FE           MOV     R6,A
   \   0001F4   E5B8         MOV     A,0xb8
   \   0001F6   FF           MOV     R7,A
   \   0001F7   E59A         MOV     A,0x9a
   \   0001F9   F5..         MOV     ?V0 + 0,A
   \   0001FB   53A820       ANL     0xa8,#0x20
   \   0001FE   53B820       ANL     0xb8,#0x20
   \   000201   539A12       ANL     0x9a,#0x12
    416                HAL_ENABLE_INTERRUPTS();
   \   000204   D2AF         SETB    0xa8.7
    417          
    418                /* set CC2530 power mode, interrupt is disabled after this function
    419                 * Note that an ISR (that could wake up from power mode) which runs
    420                 * between the previous instruction enabling interrupts and before
    421                 * power mode is set would switch the halSleepPconValue so that
    422                 * power mode shall not be entered in such a case. 
    423                 */
    424                HAL_SLEEP_SET_POWER_MODE();
   \   000206                ; Setup parameters for call to function halSetSleepMode
   \   000206   12....       LCALL   ??halSetSleepMode?relay
    425          
    426                /* the interrupt is disabled - see halSetSleepMode() */
    427          
    428                /* restore interrupt enable registers */
    429                HAL_SLEEP_IE_RESTORE(ien0, ien1, ien2);
   \   000209   8EA8         MOV     0xa8,R6
   \   00020B   8FB8         MOV     0xb8,R7
   \   00020D   85..9A       MOV     0x9a,?V0 + 0
    430          
    431                /* disable sleep timer interrupt */
    432                HAL_SLEEP_TIMER_DISABLE_INT();
   \   000210   C2AD         CLR     0xa8.5
    433          
    434          #ifdef HAL_SLEEP_DEBUG_LED
    435                HAL_TURN_ON_LED3();
    436          #else
    437                /* use this to turn LEDs back on after sleep */
    438                HalLedExitSleep();
   \   000212                ; Setup parameters for call to function HalLedExitSleep
   \   000212   12....       LCALL   ??HalLedExitSleep?relay
    439          #endif
    440          
    441          #if ((defined HAL_KEY) && (HAL_KEY == TRUE))
    442                /* handle peripherals */
    443                (void)HalKeyExitSleep();
   \   000215                ; Setup parameters for call to function HalKeyExitSleep
   \   000215   12....       LCALL   ??HalKeyExitSleep?relay
    444          #endif
    445          
    446                /* power on the MAC; blocks until completion */
    447                MAC_PwrOnReq();
   \   000218                ; Setup parameters for call to function MAC_PwrOnReq
   \   000218   12....       LCALL   ??MAC_PwrOnReq?relay
    448          
    449                HAL_ENABLE_INTERRUPTS();
   \   00021B   D2AF         SETB    0xa8.7
    450          
    451                /* For CC2530, T2 interrupt wont be generated when the current count is greater than
    452                 * the comparator. The interrupt is only generated when the current count is equal to
    453                 * the comparator. When the CC2530 is waking up from sleep, there is a small window
    454                 * that the count may be grater than the comparator, therefore, missing the interrupt.
    455                 * This workaround will call the T2 ISR when the current T2 count is greater than the
    456                 * comparator. The problem only occurs when POWER_SAVING is turned on, i.e. the 32KHz
    457                 * drives the chip in sleep and SYNC start is used.
    458                 */
    459                macMcuTimer2OverflowWorkaround();
   \   00021D                ; Setup parameters for call to function macMcuTimer2OverflowWorkaround
   \   00021D   12....       LCALL   ??macMcuTimer2OverflowWorkaround?relay
   \   000220   8002         SJMP    ??halSleep_3
    460              }
    461              else
    462              {
    463                /* An interrupt may have changed the sleep decision. Do not sleep at all. Turn on
    464                 * the interrupt, exit normally, and the next sleep will be allowed.
    465                 */
    466                HAL_ENABLE_INTERRUPTS();
   \                     ??halSleep_5:
   \   000222   D2AF         SETB    0xa8.7
    467              }
    468            }
    469          }
   \                     ??halSleep_3:
   \   000224   7F0C         MOV     R7,#0xc
   \   000226   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000229                REQUIRE _A_IEN0
   \   000229                REQUIRE _A_IRCON
   \   000229                REQUIRE SLEEPCMD
   \   000229                REQUIRE STLOAD
   \   000229                REQUIRE _A_IEN1
   \   000229                REQUIRE IEN2

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ?Subroutine0:
   \   000000   E5..         MOV     A,?V0 + 0
   \   000002                REQUIRE ??Subroutine1_0
   \   000002                ; // Fall through to label ??Subroutine1_0

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
   \                     ??Subroutine1_0:
   \   000000   45..         ORL     A,?V0 + 1
   \   000002   45..         ORL     A,?V0 + 2
   \   000004   45..         ORL     A,?V0 + 3
   \   000006   22           RET
    470          
    471          /**************************************************************************************************
    472           * @fn          halSleepSetTimer
    473           *
    474           * @brief       This function sets the CC2530 sleep timer compare value.  First it reads and
    475           *              stores the value of the sleep timer; this value is used later to update OSAL
    476           *              timers.  Then the timeout value is converted from 320 usec units to 32 kHz
    477           *              period units and the compare value is set to the timeout.
    478           *
    479           * input parameters
    480           *
    481           * @param       timeout - Timeout value in 320 usec units.  The sleep timer compare is set to
    482           *                        this value.
    483           *
    484           * output parameters
    485           *
    486           * None.
    487           *
    488           * @return      None.
    489           **************************************************************************************************
    490           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    491          void halSleepSetTimer(uint32 timeout)
   \                     halSleepSetTimer:
    492          {
   \   000000   74F0         MOV     A,#-0x10
   \   000002   12....       LCALL   ?BANKED_ENTER_XDATA
   \   000005                ; Saved register size: 16
   \   000005                ; Auto size: 4
   \   000005   74FC         MOV     A,#-0x4
   \   000007   12....       LCALL   ?ALLOC_XSTACK8
   \   00000A   8A..         MOV     ?V0 + 0,R2
   \   00000C   8B..         MOV     ?V0 + 1,R3
   \   00000E   8C..         MOV     ?V0 + 2,R4
   \   000010   8D..         MOV     ?V0 + 3,R5
    493            uint32 ticks;
    494          
    495            /* read the sleep timer; ST0 must be read first */
    496            ((uint8 *) &ticks)[UINT32_NDX0] = ST0;
   \   000012   E595         MOV     A,0x95
   \   000014   85..82       MOV     DPL,?XSP + 0
   \   000017   85..83       MOV     DPH,?XSP + 1
   \   00001A   F0           MOVX    @DPTR,A
    497            ((uint8 *) &ticks)[UINT32_NDX1] = ST1;
   \   00001B   E596         MOV     A,0x96
   \   00001D   C0E0         PUSH    A
   \   00001F   7401         MOV     A,#0x1
   \   000021   12....       LCALL   ?XSTACK_DISP0_8
   \   000024   D0E0         POP     A
   \   000026   F0           MOVX    @DPTR,A
    498            ((uint8 *) &ticks)[UINT32_NDX2] = ST2;
   \   000027   E597         MOV     A,0x97
   \   000029   C0E0         PUSH    A
   \   00002B   7402         MOV     A,#0x2
   \   00002D   12....       LCALL   ?XSTACK_DISP0_8
   \   000030   D0E0         POP     A
   \   000032   F0           MOVX    @DPTR,A
    499            ((uint8 *) &ticks)[UINT32_NDX3] = 0;
   \   000033   7403         MOV     A,#0x3
   \   000035   12....       LCALL   ?XSTACK_DISP0_8
   \   000038   E4           CLR     A
   \   000039   F0           MOVX    @DPTR,A
    500          
    501            /* Compute sleep timer compare value.  The ratio of 32 kHz ticks to 320 usec ticks
    502             * is 32768/3125 = 10.48576.  This is nearly 671/64 = 10.484375.
    503             */
    504            ticks += (timeout * 671) / 64;
    505          
    506            /* subtract the processing time spent in function halSleep() */
    507            ticks -= HAL_SLEEP_ADJ_TICKS;
   \   00003A   90....       MOV     DPTR,#__Constant_29f
   \   00003D   78..         MOV     R0,#?V0 + 4
   \   00003F   12....       LCALL   ?L_MOV_X
   \   000042   78..         MOV     R0,#?V0 + 0
   \   000044   79..         MOV     R1,#?V0 + 4
   \   000046   12....       LCALL   ?L_MUL
   \   000049   7406         MOV     A,#0x6
   \   00004B   78..         MOV     R0,#?V0 + 0
   \   00004D   12....       LCALL   ?UL_SHR
   \   000050   90....       MOV     DPTR,#__Constant_ffffffe9
   \   000053   78..         MOV     R0,#?V0 + 0
   \   000055   12....       LCALL   ?L_ADD_X
   \   000058   85..82       MOV     DPL,?XSP + 0
   \   00005B   85..83       MOV     DPH,?XSP + 1
   \   00005E   78..         MOV     R0,#?V0 + 0
   \   000060   12....       LCALL   ?L_ADD_TO_X
    508          
    509            /* set sleep timer compare; ST0 must be written last */
    510            ST2 = ((uint8 *) &ticks)[UINT32_NDX2];
   \   000063   7402         MOV     A,#0x2
   \   000065   12....       LCALL   ?XSTACK_DISP0_8
   \   000068   E0           MOVX    A,@DPTR
   \   000069   F597         MOV     0x97,A
    511            ST1 = ((uint8 *) &ticks)[UINT32_NDX1];
   \   00006B   7401         MOV     A,#0x1
   \   00006D   12....       LCALL   ?XSTACK_DISP0_8
   \   000070   E0           MOVX    A,@DPTR
   \   000071   F596         MOV     0x96,A
    512            ST0 = ((uint8 *) &ticks)[UINT32_NDX0];
   \   000073   85..82       MOV     DPL,?XSP + 0
   \   000076   85..83       MOV     DPH,?XSP + 1
   \   000079   E0           MOVX    A,@DPTR
   \   00007A   F595         MOV     0x95,A
    513          }
   \   00007C   7404         MOV     A,#0x4
   \   00007E   12....       LCALL   ?DEALLOC_XSTACK8
   \   000081   7F08         MOV     R7,#0x8
   \   000083   02....       LJMP    ?BANKED_LEAVE_XDATA
   \   000086                REQUIRE ST0
   \   000086                REQUIRE ST1
   \   000086                REQUIRE ST2
    514          
    515          /**************************************************************************************************
    516           * @fn          TimerElapsed
    517           *
    518           * @brief       Determine the number of OSAL timer ticks elapsed during sleep.
    519           *              Deprecated for CC2530 and CC2430 SoC.
    520           *
    521           * input parameters
    522           *
    523           * @param       None.
    524           *
    525           * output parameters
    526           *
    527           * None.
    528           *
    529           * @return      Number of timer ticks elapsed during sleep.
    530           **************************************************************************************************
    531           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    532          uint32 TimerElapsed( void )
   \                     TimerElapsed:
    533          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    534            /* Stubs */
    535            return (0);
   \   000000   7A00         MOV     R2,#0x0
   \   000002   7B00         MOV     R3,#0x0
   \   000004   7C00         MOV     R4,#0x0
   \   000006   7D00         MOV     R5,#0x0
   \   000008   02....       LJMP    ?BRET
    536          }
    537          
    538          /**************************************************************************************************
    539           * @fn          halRestoreSleepLevel
    540           *
    541           * @brief       Restore the deepest timer sleep level.
    542           *
    543           * input parameters
    544           *
    545           * @param       None
    546           *
    547           * output parameters
    548           *
    549           *              None.
    550           *
    551           * @return      None.
    552           **************************************************************************************************
    553           */

   \                                 In  segment BANKED_CODE, align 1, keep-with-next
    554          void halRestoreSleepLevel( void )
   \                     halRestoreSleepLevel:
    555          {
   \   000000                ; Saved register size: 0
   \   000000                ; Auto size: 0
    556            /* Stubs */
    557          }
   \   000000   02....       LJMP    ?BRET
    558          
    559          /**************************************************************************************************
    560           * @fn          halSleepTimerIsr
    561           *
    562           * @brief       Sleep timer ISR.
    563           *
    564           * input parameters
    565           *
    566           * None.
    567           *
    568           * output parameters
    569           *
    570           * None.
    571           *
    572           * @return      None.
    573           **************************************************************************************************
    574           */

   \                                 In  segment NEAR_CODE, align 1, keep-with-next
    575          HAL_ISR_FUNCTION(halSleepTimerIsr, ST_VECTOR)
   \                     halSleepTimerIsr:
    576          {
   \   000000   C0E0         PUSH    A
   \   000002   C0D0         PUSH    PSW
   \   000004   E8           MOV     A,R0
   \   000005   C0E0         PUSH    A
   \   000007                ; Saved register size: 3
   \   000007                ; Auto size: 0
    577            HAL_ENTER_ISR();
   \   000007   E5A8         MOV     A,0xa8
   \   000009   D2AF         SETB    0xa8.7
    578            HAL_SLEEP_TIMER_CLEAR_INT();
   \   00000B   C2C7         CLR     0xc0.7
    579          
    580          #ifdef HAL_SLEEP_DEBUG_POWER_MODE
    581            halSleepInt = TRUE;
    582          #endif
    583            
    584            CLEAR_SLEEP_MODE();
   \   00000D   75..00       MOV     halSleepPconValue,#0x0
    585            HAL_EXIT_ISR();
   \   000010   A2E7         MOV     C,0xE0 /* A   */.7
   \   000012   92AF         MOV     0xa8.7,C
    586          }
   \   000014   D0E0         POP     A
   \   000016   F8           MOV     R0,A
   \   000017   D0D0         POP     PSW
   \   000019   D0E0         POP     A
   \   00001B   32           RETI
   \   00001C                REQUIRE _A_IEN0
   \   00001C                REQUIRE _A_IRCON

   \                                 In  segment INTVEC, offset 0x2b, root
   \                     `??halSleepTimerIsr??INTVEC 43`:
   \   00002B   02....       LJMP       (halSleepTimerIsr)

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for Time_Interval>`:
   \   000000   80EE3600     DD 3600000

   \                                 In  segment XDATA_ID, align 1, keep-with-next
   \                     `?<Initializer for maxSleepLoopTime>`:
   \   000000   96511800     DD 1593750

   \                                 In  segment DATA_ID, align 1, keep-with-next
   \                     `?<Initializer for halSleepPconValue>`:
   \   000000   01           DB 1

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_fffffffe:
   \   000000   FEFFFFFF     DD 4294967294

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_64:
   \   000000   64000000     DD 100

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1f:
   \   000000   1F000000     DD 31

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_2d:
   \   000000   2D000000     DD 45

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1d4c0:
   \   000000   C0D40100     DD 120000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_36ee80:
   \   000000   80EE3600     DD 3600000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_4d58:
   \   000000   584D0000     DD 19800

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_fa00:
   \   000000   00FA0000     DD 64000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_1388:
   \   000000   88130000     DD 5000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_57e40:
   \   000000   407E0500     DD 360000

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_29f:
   \   000000   9F020000     DD 671

   \                                 In  segment XDATA_ROM_C, align 1
   \                     __Constant_ffffffe9:
   \   000000   E9FFFFFF     DD 4294967273

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSetSleepMode?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSetSleepMode

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSetMaxSleepLoopTime?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSetMaxSleepLoopTime

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleep?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleep

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halSleepSetTimer?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halSleepSetTimer

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??TimerElapsed?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    TimerElapsed

   \                                 In  segment BANK_RELAYS, align 1
   \                     ??halRestoreSleepLevel?relay:
   \   000000   12....       LCALL   ?BDISPATCH
   \   000003   ......       DC24    halRestoreSleepLevel
    587          

   Maximum stack usage in bytes:

     Function                       ISTACK PSTACK XSTACK
     --------                       ------ ------ ------
     TimerElapsed                       0      0      0
     halRestoreSleepLevel               0      0      0
     halSetMaxSleepLoopTime             0      0     12
     halSetSleepMode                    0      0     20
     halSleep                           0      0     20
       -> MAC_PwrNextTimeout            0      0     40
       -> MAC_PwrNextTimeout            0      0     40
       -> halAssertHandler              0      0     40
       -> MAC_PwrOffReq                 0      0     40
       -> HalKeyEnterSleep              0      0     40
       -> HalLedEnterSleep              0      0     40
       -> halSleepSetTimer              0      0     40
       -> halSetSleepMode               0      0     40
       -> HalLedExitSleep               0      0     40
       -> HalKeyExitSleep               0      0     40
       -> MAC_PwrOnReq                  0      0     40
       -> macMcuTimer2OverflowWorkaround
                                        0      0     40
     halSleepSetTimer                   1      0     40
     halSleepTimerIsr                   3      0      0


   Segment part sizes:

     Function/Label                       Bytes
     --------------                       -----
     PCON                                    1
     ST0                                     1
     ST1                                     1
     ST2                                     1
     IEN2                                    1
     _A_IEN0                                 1
     STLOAD                                  1
     _A_IEN1                                 1
     SLEEPCMD                                1
     _A_IRCON                                1
     Time_Interval                           4
     maxSleepLoopTime                        4
     halSleepPconValue                       1
     halPwrMgtMode                           1
     halSetSleepMode                         8
     halSetMaxSleepLoopTime                 34
     halSleep                              553
     ?Subroutine0                            2
     ??Subroutine1_0                         7
     halSleepSetTimer                      134
     TimerElapsed                           11
     halRestoreSleepLevel                    3
     halSleepTimerIsr                       28
     ??halSleepTimerIsr??INTVEC 43           3
     ?<Initializer for Time_Interval>        4
     ?<Initializer for maxSleepLoopTime>     4
     ?<Initializer for halSleepPconValue>    1
     __Constant_fffffffe                     4
     __Constant_64                           4
     __Constant_1f                           4
     __Constant_2d                           4
     __Constant_1d4c0                        4
     __Constant_36ee80                       4
     __Constant_4d58                         4
     __Constant_fa00                         4
     __Constant_1388                         4
     __Constant_57e40                        4
     __Constant_29f                          4
     __Constant_ffffffe9                     4
     ??halSetSleepMode?relay                 6
     ??halSetMaxSleepLoopTime?relay          6
     ??halSleep?relay                        6
     ??halSleepSetTimer?relay                6
     ??TimerElapsed?relay                    6
     ??halRestoreSleepLevel?relay            6

 
 744 bytes in segment BANKED_CODE
  36 bytes in segment BANK_RELAYS
   1 byte  in segment DATA_I
   1 byte  in segment DATA_ID
   3 bytes in segment INTVEC
  28 bytes in segment NEAR_CODE
  10 bytes in segment SFR_AN
   8 bytes in segment SLEEP_CODE
   8 bytes in segment XDATA_I
   8 bytes in segment XDATA_ID
  48 bytes in segment XDATA_ROM_C
   1 byte  in segment XDATA_Z
 
 825 bytes of CODE  memory (+  3 bytes shared)
   0 bytes of CONST memory (+ 48 bytes shared)
   1 byte  of DATA  memory (+ 10 bytes shared)
   9 bytes of XDATA memory

Errors: none
Warnings: none
